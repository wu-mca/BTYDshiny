{
    "collab_server" : "",
    "contents" : "library(BTYD)\nlibrary(shiny)\nlibrary(dplyr)\nlibrary(BTYDplus)\nlibrary(data.table)\nlibrary(ggplot2)\nlibrary(tidyr)\n\ncdnow <- fread('cdnow_elog.csv')\ncdnow[, date := as.Date(date, '%Y-%m-%d')]\ncdnow[, first := min(date), by='cust']\n\n\n\ngrocery <- fread('grocery-elog.csv')[, first:=NULL]\ngrocery[, date := as.Date(date, '%Y-%m-%d')]\ngrocery[, first := min(date), by='cust']\n\n\ndonations <- fread('donations-elog.csv')\ndonations[, date := as.Date(date, format='%m/%d/%Y')]\ndonations[, first := min(date), by='cust']\n\n\n\n\n\nui <- fluidPage(\n    headerPanel('BTYD shiny demo'),\n    sidebarPanel(\n        selectInput('Data','Select the dataset',choices = c('CDNOW','Donations','Grocery')),\n        selectInput('Model','Select the model',choices = c('Pareto/NBD', 'BG/NBD', 'MBG/NBD', 'MBG/CNBD-k')),\n        sliderInput(\"cal_per\",value = 50,max = 90,min = 10,post = '%',label = \"Calibration/holdout split\"),\n        width = 3\n    ),\n    mainPanel(tabsetPanel(\n        tabPanel(title = 'Descriptive Summary Statistic',\n                 tableOutput('descr_stats'),\n\n                 h4('Plot Of Timing Patterns'),\n                 plotOutput('tim_pat')),\n        tabPanel(title = 'Cohort Level Analysis',\n                 h4('Estimated Parameters '),\n                 tableOutput('est_param'),\n\n                 h4('Tracking Incremental & Cumulative Weekly'),\n                 plotOutput('incr_weekly'),\n                 plotOutput('cum_weekly'),\n\n                 h4('Frequency and Recency vs Holdout Transactions'),\n                 plotOutput('freq_trans'),\n                 plotOutput('rec_trans'),\n\n\n\n                 h4('distribution of P(alive)'),\n                 plotOutput('p_alive')),\n\n        tabPanel(title = 'Customer Level Analysis',\n                 h4('Mean Absolute Error & Bias'),\n                 tableOutput('stats'),\n\n                 h4('Sufficient Statistic Matrix'),\n                 tableOutput('suf_mat'))\n    )\n    )\n\n)\n\nserver <- function(input,output){\n    data_elog <- reactive({\n        data <- list(CDNOW = cdnow, Grocery = grocery,Donations = donations)\n        data$selected <- data[[input$Data]]\n        data\n    })\n\n    data_cbs <- reactive({\n        cbs_cdnow <- elog2cbs(cdnow, units = 'week', T.cal = sort(unique(cdnow$date))[uniqueN(cdnow$date)*input$cal_per/100])\n        cbs_cdnow <- as.data.frame(cbs_cdnow)\n\n        cbs_grocery <- elog2cbs(grocery, T.cal = sort(unique(grocery$date))[uniqueN(grocery$date)*input$cal_per/100])\n        cbs_grocery <- as.data.frame(cbs_grocery)\n        #Take the length of the unique dates in dataset and * on the number from 0.1 till 0.9 => new date for calibration period.\n        cbs_donations <- elog2cbs(donations, units='week', T.cal = sort(unique(donations$date))[uniqueN(donations$date)*input$cal_per/100])\n        cbs_donations <- as.data.frame(cbs_donations)\n\n        data <- list(CDNOW = cbs_cdnow, Grocery = cbs_grocery,Donations = cbs_donations)\n        data$selected <- data[[input$Data]]\n\n        data\n    })\n\n    model <- reactive({\n        data <- data_cbs()$selected\n        if(input$Model == \"Pareto/NBD\"){\n            params.pnbd <- BTYD::pnbd.EstimateParameters(data,max.param.value = 100)\n            palive.pnbd <- BTYD::pnbd.PAlive(params = params.pnbd, data$x, data$t.x, data$T.cal)\n            plot_freq_trans_fn <- pnbd.PlotFreqVsConditionalExpectedFrequency\n            incr_weekly <- pnbd.PlotTrackingInc\n            cum_weekly <- pnbd.PlotTrackingCum\n            rec_trans <- pnbd.PlotRecVsConditionalExpectedFrequency\n\n            est_param <- rbind(params.pnbd)\n            colnames(est_param) <- c(\"r\", \"alpha\", \"s\", \"beta\")\n\n            suf_mat <- data\n            suf_mat$palive.pnbd <- palive.pnbd\n            suf_mat$xstar.pnbd <- BTYD::pnbd.ConditionalExpectedTransactions(\n                params  = params.pnbd,\n                T.star  = suf_mat$T.star,\n                x       = suf_mat$x,\n                t.x     = suf_mat$t.x,\n                T.cal   = suf_mat$T.cal)\n            suf_mat <- arrange(suf_mat,desc(xstar.pnbd))\n            rows_middle <- (nrow(suf_mat)/2) + 5\n            suf_mat <- as.data.frame(rbind(head(suf_mat),suf_mat[(nrow(suf_mat)/2):rows_middle,],tail(suf_mat)))\n\n\n            measures <- c(\n                \"MAE\" = function(a, f) mean(abs(a - f)),\n                \"MSLE\" = function(a, f) mean(((log(a + 1) - log(f + 1)))^2),\n                \"BIAS\" = function(a, f) sum(f)/sum(a) - 1)\n            models <- c(\"Pareto/NBD\" = \"pnbd\")\n\n            errors <- sapply(measures, function(measure) {\n                sapply(models, function(model) {\n                    err <- do.call(measure, list(a = data$x.star, f = data[[paste0(\"xstar.\", model)]]))\n                    round(err, 3)\n                    err\n                })\n            })\n\n\n\n            l <- list(params = params.pnbd,palive = palive.pnbd,plot_freq = plot_freq_trans_fn,incr_weekly = incr_weekly,cum_weekly = cum_weekly,rec_trans = rec_trans,est_param = est_param,suf_mat = suf_mat,errors = errors)\n        }else if(input$Model == \"BG/NBD\"){\n            params.bgnbd <- BTYD::bgnbd.EstimateParameters(data)\n            palive.bgnbd <- BTYD::bgnbd.PAlive(params = params.bgnbd, data$x, data$t.x, data$T.cal)\n            plot_freq_trans_fn <- bgnbd.PlotFreqVsConditionalExpectedFrequency\n            incr_weekly <- bgnbd.PlotTrackingInc\n            cum_weekly <-  bgnbd.PlotTrackingCum\n            rec_trans <-  bgnbd.PlotRecVsConditionalExpectedFrequency\n\n            est_param <- rbind(params.bgnbd)\n            colnames(est_param) <- c(\"r\", \"alpha\", \"a\", \"b\")\n\n            suf_mat <- data\n            suf_mat$palive.bgnbd <- palive.bgnbd\n            suf_mat$xstar.bgnbd <-  BTYD::bgnbd.ConditionalExpectedTransactions(\n                params  = params.bgnbd,\n                T.star  = suf_mat$T.star,\n                x       = suf_mat$x,\n                t.x     = suf_mat$t.x,\n                T.cal   = suf_mat$T.cal)\n            suf_mat <- arrange(suf_mat,desc(xstar.bgnbd))\n            rows_middle <- (nrow(suf_mat)/2) + 5\n            suf_mat <- as.data.frame(rbind(head(suf_mat),suf_mat[(nrow(suf_mat)/2):rows_middle,],tail(suf_mat)))\n\n            measures <- c(\n                \"MAE\" = function(a, f) mean(abs(a - f)),\n                \"MSLE\" = function(a, f) mean(((log(a + 1) - log(f + 1)))^2),\n                \"BIAS\" = function(a, f) sum(f)/sum(a) - 1)\n            models <- c(\"BG/NBD\" = \"bgnbd\")\n\n            errors <- sapply(measures, function(measure) {\n                sapply(models, function(model) {\n                    err <- do.call(measure, list(a = data$x.star, f = data[[paste0(\"xstar.\", model)]]))\n                    round(err, 3)\n                })\n            })\n\n            l <- list(params = params.bgnbd,palive = palive.bgnbd,plot_freq = plot_freq_trans_fn,incr_weekly = incr_weekly,cum_weekly = cum_weekly,rec_trans = rec_trans,est_param = est_param,suf_mat = suf_mat,errors = errors)\n        }else if(input$Model == \"MBG/NBD\"){\n            params.mbgnbd <- mbgnbd.EstimateParameters(data)\n            palive.mbgnbd <- mbgcnbd.PAlive(params = params.mbgnbd, data$x, data$t.x, data$T.cal)\n            incr_weekly <- mbgcnbd.PlotTrackingInc\n            cum_weekly <- mbgcnbd.PlotTrackingCum\n\n            est_param <- rbind(params.mbgnbd)\n            colnames(est_param) <- c(\"k\",\"r\", \"alpha\", \"a\", \"b\")\n\n            suf_mat <- data\n            suf_mat$palive.mbgnbd <- palive.mbgnbd\n            suf_mat$xstar.mbgnbd <- mbgcnbd.ConditionalExpectedTransactions(\n                params  = params.mbgnbd,\n                T.star  = suf_mat$T.star,\n                x       = suf_mat$x,\n                t.x     = suf_mat$t.x,\n                T.cal   = suf_mat$T.cal)\n            suf_mat <- arrange(suf_mat,desc(xstar.mbgnbd))\n            rows_middle <- (nrow(suf_mat)/2) + 5\n            suf_mat <- as.data.frame(rbind(head(suf_mat),suf_mat[(nrow(suf_mat)/2):rows_middle,],tail(suf_mat)))\n\n            measures <- c(\n                \"MAE\" = function(a, f) mean(abs(a - f)),\n                \"MSLE\" = function(a, f) mean(((log(a + 1) - log(f + 1)))^2),\n                \"BIAS\" = function(a, f) sum(f)/sum(a) - 1)\n            models <- c(\"MBG/NBD\" = \"mbgnbd\")\n\n            errors <- sapply(measures, function(measure) {\n                sapply(models, function(model) {\n                    err <- do.call(measure, list(a = data$x.star, f = data[[paste0(\"xstar.\", model)]]))\n                    round(err, 3)\n                })\n            })\n\n            l <- list(params = params.mbgnbd,palive = palive.mbgnbd,incr_weekly = incr_weekly,cum_weekly = cum_weekly,est_param = est_param,suf_mat = suf_mat)\n        }else if(input$Model == \"MBG/CNBD-k\"){\n            params.mbgcnbd <- mbgcnbd.EstimateParameters(data)\n            palive.mbgcnbd <- mbgcnbd.PAlive(params = params.mbgcnbd, data$x, data$t.x, data$T.cal)\n            incr_weekly <- mbgcnbd.PlotTrackingInc\n            cum_weekly <- mbgcnbd.PlotTrackingCum\n\n            est_param <- rbind(params.mbgcnbd)\n            colnames(est_param) <- c(\"k\",\"r\", \"alpha\", \"a\", \"b\")\n\n            suf_mat <- data\n            suf_mat$palive.mbgcnbd <- palive.mbgcnbd\n            suf_mat$xstar.mbgcnbd <- mbgcnbd.ConditionalExpectedTransactions(\n                params  = params.mbgcnbd,\n                T.star  = suf_mat$T.star,\n                x       = suf_mat$x,\n                t.x     = suf_mat$t.x,\n                T.cal   = suf_mat$T.cal)\n            suf_mat <- arrange(suf_mat,desc(xstar.mbgcnbd))\n            rows_middle <- (nrow(suf_mat)/2) + 5\n            suf_mat <- as.data.frame(rbind(head(suf_mat),suf_mat[(nrow(suf_mat)/2):rows_middle,],tail(suf_mat)))\n\n            measures <- c(\n                \"MAE\" = function(a, f) mean(abs(a - f)),\n                \"MSLE\" = function(a, f) mean(((log(a + 1) - log(f + 1)))^2),\n                \"BIAS\" = function(a, f) sum(f)/sum(a) - 1)\n            models <- c(\"MBG/CNBD-k\" = \"mbgcnbd\")\n\n            errors <- sapply(measures, function(measure) {\n                sapply(models, function(model) {\n                    err <- do.call(measure, list(a = data$x.star, f = data[[paste0(\"xstar.\", model)]]))\n                    round(err, 3)\n                })\n            })\n\n            l <- list(params = params.mbgcnbd,palive = palive.mbgcnbd,incr_weekly = incr_weekly,cum_weekly = cum_weekly,est_param = est_param,suf_mat = suf_mat)\n        }\n\n    })\n\n    output$descr_stats <- renderTable({\n        cbs_cdnow <- data_cbs()$CDNOW\n        cbs_grocery <- data_cbs()$Grocery\n        cbs_donations <- data_cbs()$Donations\n        #a)dataset\n        dataset <- c(\"CDs\",\"Grocery\",\"Donations\")\n        #b)Cohort size\n        coh.size <- c(nrow(cbs_cdnow),nrow(cbs_grocery),nrow(cbs_donations))\n        #c)Period length in weeks(Calibration)\n        per.length.cal <- c(round(max(cbs_cdnow$T.cal)),round(max(cbs_grocery$T.cal)),round(max(cbs_donations$T.cal)))\n        #d)Period length in weeks(holdout)\n        per.length.hold <- c(round(cbs_cdnow$T.star[1]),round(cbs_grocery$T.star[1]),round(cbs_donations$T.star[1]))\n        #e)share of inactive customer(calibr)\n        sh.in.cust.cal <- c(round(sum(cbs_cdnow$x == 0)/nrow(cbs_cdnow),2),round(sum(cbs_grocery$x == 0)/nrow(cbs_grocery),2),\n                            round(sum(cbs_donations$x == 0)/nrow(cbs_donations),2))*100\n        #f)share of inactive customer(holdout)\n        sh.in.cust.hold <- c(round(sum(cbs_cdnow$x.star == 0)/nrow(cbs_cdnow),2),round(sum(cbs_grocery$x.star == 0)/nrow(cbs_grocery),2),\n                             round(sum(cbs_donations$x.star == 0)/nrow(cbs_donations),2))*100\n        #g)share of customers with 4 or > transactions(calibration)\n        sh.cust.4.plus.cal <- c(round((sum(cbs_cdnow$x >=4)/nrow(cbs_cdnow)),2),round(sum((cbs_grocery$x >=4)/nrow(cbs_grocery)),2),round(sum((cbs_donations$x >=4)/nrow(cbs_donations)),2))*100\n        #h)share of customers with 4 or > transactions(holdout)\n        sh.cust.4.plus.hold <- c(round((sum(cbs_cdnow$x.star >=4)/nrow(cbs_cdnow)),2),round(sum((cbs_grocery$x.star >=4)/nrow(cbs_grocery)),2),round(sum((cbs_donations$x.star >=4)/nrow(cbs_donations)),2))*100\n        #i)mean 0f number of purchases(calibr)\n        num.purch.cal <- c(round(mean(cbs_cdnow$x),2),round(mean(cbs_grocery$x),2),round(mean(cbs_donations$x),2))\n        #j)mean 0f number of purchases(holdout)\n        num.purch.hold <- c(round(mean(cbs_cdnow$x.star),2),round(mean(cbs_grocery$x.star),2),round(mean(cbs_donations$x.star),2))\n        #k)mean 0f number of purchases active cust(calibr)\n        num.purch.cal.act <- c(round(mean(cbs_cdnow$x[cbs_cdnow$x>0]),2),round(mean(cbs_grocery$x[cbs_grocery$x>0]),2),round(mean(cbs_donations$x[cbs_donations$x>0]),2))\n        #l)mean 0f number of purchases active cust(hold)\n        num.purch.hold.act <- c(round(mean(cbs_cdnow$x.star[cbs_cdnow$x.star>0]),2),round(mean(cbs_grocery$x.star[cbs_grocery$x.star>0]),2),round(mean(cbs_donations$x.star[cbs_donations$x.star>0]),2))\n        #m)wheat\n        wheat <- c(round(estimateRegularity(cdnow, method = \"wheat\",plot = FALSE),2),round(estimateRegularity(grocery, method = \"wheat\",plot = FALSE),2),round(estimateRegularity(donations, method = \"wheat\",plot = FALSE),2))\n        #Table:\n        des_stat <- c()\n        des_stat<- cbind(des_stat ,dataset,coh.size,per.length.cal,per.length.hold,sh.in.cust.cal,sh.in.cust.hold,\n                         sh.cust.4.plus.cal,sh.cust.4.plus.hold,num.purch.cal,num.purch.hold,\n                         num.purch.cal.act,num.purch.hold.act,wheat)\n        des_stat <- as.data.frame(des_stat)\n        des_stat[,5:8] <- lapply(des_stat[,5:8],function(x){paste(x,'%',sep = \"\")})\n        des_stat <- data.frame(lapply(des_stat, as.character), stringsAsFactors=FALSE)\n        d <- cbind(des_stat[1:2], do.call(cbind, lapply(c(3,5,7,9,11), function(i) do.call(paste, c(des_stat[i:(i+1)], sep=\"/\")))))\n        d <- cbind(d,wheat)\n        d <- as.data.frame(d)\n\n        colnames(d) <- c(\"Dataset\",\"Cohort size\",\"Period length (Calibration/Holdout)\",\"Share of inactive customer(cal/hol)\",\n                         \"Share of customers with 4 or > transactions(cal/hol)\",\"Mean of № of purchases(cal/hol)\",\n                         \"Mean of № of purchases active cust(cal/hol)\",'wheat')\n        d\n    })\n\n\n\n    output$tim_pat <- renderPlot({\n        data <- data_elog()$selected\n        plotTimingPatterns(data, n = 30, T.cal = sort(unique(data$date))[uniqueN(data$date)*input$cal_per/100],\n                           headers = c(\"Calibration Period\", \"Holdout Period\"), title = \"\")\n    })\n\n\n\n    output$p_alive <- renderPlot({\n        plot <- ggplot(as.data.frame(model()$palive),aes(x=model()$palive))+\n            geom_histogram(binwidth =0.01,colour=\"black\",fill=\"orange\")+\n            ylab(\"Number of Customers\")+\n            xlab(\"Probability Customer is 'Live'\")+\n            theme_minimal()\n        plot\n        })\n\n    output$freq_trans <-renderPlot({\n        data <- data_cbs()$selected\n        param <- model()$params\n        model()$plot_freq(param,data$T.star[1],data ,data$x.star,censor =7)\n\n        })\n\n\n    output$incr_weekly <-renderPlot({\n        data <- data_elog()$selected\n        data_cbs <- data_cbs()$selected\n        param <-model()$params\n        model()$incr_weekly(param,data_cbs$T.cal,T.tot = 78,actual.inc.tracking.data =elog2inc(data))\n        })\n\n    output$cum_weekly <- renderPlot({\n        data <- data_elog()$selected\n        data_cbs <- data_cbs()$selected\n        param <-model()$params\n        model()$cum_weekly(param,data_cbs$T.cal,T.tot = 78,actual.cu.tracking.data =elog2cum(data))\n        })\n\n    output$est_param <- renderTable({\n        est_param<-model()$est_param\n        })\n\n    output$rec_trans <-renderPlot({\n        data_cbs <- data_cbs()$selected\n        param <-model()$params\n        model()$rec_trans(param,data_cbs,data_cbs$T.star[1],data_cbs$x.star)\n        })\n    ##no sales data in Donations and Grocery\n    output$suf_mat <- renderTable({\n        model()$suf_mat\n        })\n    output$stats <- renderTable({\n        model()$errors\n        })\n}\n\nshinyApp(ui = ui, server = server)\n",
    "created" : 1481113045902.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2079845840",
    "id" : "38D7B224",
    "lastKnownWriteTime" : 1481113054,
    "last_content_update" : 1481113054363,
    "path" : "C:/Users/Daniil/Desktop/Programming/R/Work/shiny_project/BTYDshiny/app2.R",
    "project_path" : "app2.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}